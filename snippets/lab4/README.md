# Exercise: RPC-based Authentication Service

## Introduction
This is my solution for a secure JSON-based RPC Authentication Service, capable of user authentication and token validation. 
Each user can authenticate only after registering in the database, doing so thanks to a command-line interface.
Retrieving data about each user can only be done by those that in the database have the `ADMIN` role.

## Design
The solution is an extension of the solution of first given exercise. A few amount of changes were made to the previous architecture in order to make it secure. Those changes are:
- Addition of `token` field in the `Request` dataclass that must be filled with a new token that was generated first by an `authenticate` call. This is done in order to prevent any user to do certain requests without first authenticating themselves;
- Memorization of `token` generated by `authenticate` call inside the `ClientStub`. Keeping a memory of token simplifies solution by not forcing multiple useless `authenticate` calls when performing specific requests;
- Change inside the `on_handle_request` method in `ServerStub`: when server receives a `get_user` request, it first checks that received request contains a valid token (performs a `validate_token` call), then checks whether or not the `User` that made the request has the `ADMIN` role, raising an exception if it's not.
- Additions in Command-Line Interface with new `--adminUser` arg (can also use `-k` instead) to retrieve admin username.

## Testing
Testing of the new extended solution was done using both Command-Line, newly added launch configurations in `launch.json` and a single extra file in `testFiles`.

### Command-Line Testing
First we run the server on port `8080` using this command on a terminal:
```
poetry run python -m snippets -l 4 -e 2 8080
```

After that, a new terminal is opened, where we add both a new admin and a new simple user into the database. Here are some examples
- New Admin
```
poetry run python -m snippets -l 4 -e 4 localhost:8080 add -u abianchi -a andBianchi@gmail.com -n "Andrea Bianchi" -r admin -p "my_password"
```
- New User
```
poetry run python -m snippets -l 4 -e 4 localhost:8080 add -u frank -a franBianchi@gmail.com -n "Francesco Bianchi" -r user -p "my_password"
```

Before testing the newly secured `get_user`, we first must let the admin authenticate in the server:
```
poetry run python -m snippets -l 4 -e 4 localhost:8080 authenticate -u abianchi -p "my_password"
```
This can then be done to make sure the token is valid:
```
poetry run python -m snippets -l 4 -e 4 localhost:8080 validate_token -u abianchi
```
Once these processes are completed, we can retrieve the other users using `get_user`:
```
poetry run python -m snippets -l 4 -e 4 localhost:8080 get -k abianchi -u frank #retrieves data of User frank
poetry run python -m snippets -l 4 -e 4 localhost:8080 get -k abianchi -u abianchi #retrieves data of User abianchi
```

### Debug Tests With Launch.json
Along the previously implemented four new launch configurations (of which the first three must be called first before testing these additions), 2 more configurations were implemented into `launch.json` file. These are:
- Addition of a new simple user into the database
```
{
    "name": "RPC TEST 4: Add Normal User (NOT ADMIN)",
    "type": "debugpy",
    "request": "launch",
    "module": "snippets.lab4.example4_rpc_client_cli",
    "args": [
        "localhost:8080",
        "add",
        "-u",
        "frank",
        "-a",
        "frankBianchi@gmail.com",
        "-n",
        "Francesco Bianchi",
        "-r",
        "user",
        "-p",
        "password"
    ],
}
```
- Secure retrieval of user data:
```
{
    "name": "RPC TEST 5: Secure Get User",
    "type": "debugpy",
    "request": "launch",
    "module": "snippets.lab4.example4_rpc_client_cli",
    "args": [
        "localhost:8080",
        "get",
        "-k",
        "abianchi",
        "-u",
        "frank"
    ],
}
```

Starting each of these launch configurations in the shown order (`RPC TEST 0 -> RPC TEST 1 -> RPC TEST 2 -> RPC TEST 4 -> RPC TEST 5`) will showcase the success of every implemented method.

### Unit Tests
A single test file was added along the previous two.
This also contains two `@classmethod` methods. These are:
- `def setUpClass`: before starting tests, the `ServerStub` is created, along with its `RemoteUserDatabase` and `RemoteAuthenticationService`. Two new users, one with `ADMIN` role and the other with `USER` role, are then added into the database;
- `def tearDownClass`: after finishing every test contained in the class, the server is gracefully closed.

Test file **`test_secure_get_user`** focuses on testing and showcasing both successful and failing tests of user data retriveal. The file contains these 3 test functions:
- `def test_get_user_successful`: Firstly generating a token with `authenticate` method using the admin credentials. It then adds `password` to the `retrievedToken` (since method `get_user` retrieves a user with no password). It then checks with an `assertEquals` if `retrievedToken` equals with `TESTUSER` created at the start;
- `def test_get_user_failure`: This time token set in the `ClientStub` is generate by using simple user credentials. We then capture any `RuntimeException` that is generated from the `get_user` method;
- `def test_get_user_noToken`: This very simple test only focuses on capturing `RunTimeExceptions` generated by `get_user` method since no token was generated (therefore, no one tried to "authenticate" before retrieving user data).

To run the test, this command can be run through terminal:

```
poetry run python -m unittest discover -s tests -p "test_get_user.py"
```

The system has been tested only on Windows environment.